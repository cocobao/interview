

共享内存实现：

		就是分配一块能被其他进程访问的内存。共享内存可以说是最有用的进程间通信方式，也是最快的IPC形式。首先说下在使用共享内存
	区前，必须通过系统函数将其附加到进程的地址空间或说为映射到进程空间。两个不同进程A、B共享内存的意思是，同一块物理内存被映射
	到进程A、B各自的进程地址空间。进程A可以即时看到进程B对共享内存中数据的更新，反之亦然。由于多个进程共享同一块内存区域，必然
	需要某种同步机制，互斥锁和信号量都可以。采用共享内存通信的一个显而易见的好处是效率高，因为进程可以直接读写内存，而不需要任
	何数据的拷贝。对于像管道和消息队列等通信方式，则需要在内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次数据[1]：一次
	从输入文件到共享内存区，另一次从共享内存区到输出文件。实际上，进程之间在共享内存时，并不总是读写少量数据后就解除映射，有新的
	通信时，再重新建立共享内存区域。而是保持共享区域，直到通信完毕为止，这样，数据内容一直保存在共享内存中，并没有写回文件。共享
	内存中的内容往往是在解除映射时才写回文件的。因此，采用共享内存的通信方式效率是非常高的。

ELF是什么？

		可执行连接格式，是UNIX系统实验室（USL）作为应用程序二进制接口（Application Binary Interface，ABI）而开发和发布的。扩
	展名为elf。工具接口标准委员会(TIS)选择了正在发展中的ELF标准作为工作在32位INTEL体系上不同操作系统之间可移植的二进制文件格
	式。假定开发者定义了一个二进制接口集合，ELF标准用它来支持流线型的软件发展。应该减少不同执行接口的数量。因此可以减少重新编程
	重新编译的代码。
	ELF文件（目标文件）格式主要三种:
	1）可重定向文件：文件保存着代码和适当的数据，用来和其他的目标文件一起来创建一个可执行文件或者是一个共享目标文件。（目标文件或者
	静态库文件，即linux通常后缀为.a和.o的文件）
	2）可执行文件：文件保存着一个用来执行的程序。（例如bash，gcc等）
	3）共享目标文件：共享库。文件保存着代码和合适的数据，用来被下连接编辑器和动态链接器链接。（linux下后缀为.so的文件。）
	
BSS段

		BSS（Block Started by Symbol）通常是指用来存放程序中未初始化的全局变量和静态变量的一块内存区域。特点是:可读写的，在
	程序执行之前BSS段会自动清0。所以，未初始的全局变量在程序执行之前已经成0了。
	注意和数据段的区别，BSS存放的是未初始化的全局变量和静态变量，数据段存放的是初始化后的全局变量和静态变量。
	
内存分布

	可执行二进制程序 = 代码段(text)＋数据段(data)+BSS段
	正在运行的C程序 = 代码段+初始化数据段(data)+未初始化数据段(BSS)+堆+栈
	
	
进程之间通讯方式

	进程间通信：
	管道、有名管道、消息队列、信号量、共享内存、信号、套接字。
	
	线程间通信：
	（1）原子操作符集
	（2）关键代码段（Windows）
	（3）互斥锁
	（4）信号量
	（5）条件变量（Linux）
	（6）读写锁（Linux）
	
如何定位内存泄露？

		内存泄漏是指堆内存的泄漏。堆内存是指程序从堆中分配的、大小任意的（内存块的大小可以在程序运行期决定）、使用完后必须显示释
	放的内存。应用程序一般使用malloc、realloc、new等函数从堆中分配到一块内存，使用完后，程序必须负责相应的调用free或delete
	释放该内存块。否则，这块内存就不能被再次使用，我们就说这块内存泄漏了。
		C++程序缺乏相应的手段来检测内存信息，只能使用top指令观察进程的动态内存总额。而且程序退出时，我们无法获知任何内存泄漏信息
	使用Linux命令回收内存，可以使用ps、kill两个命令检测内存使用情况和进行回收。在使用超级用户权限时使用命令“ps”，它会列出所有正在运行
	的程序名称和对应的进程号（PID）。kill命令的工作原理是向Linux操作系统的内核送出一个系统操作信号和程序的进程号（PID）

动态链接和静态链接的区别

	动态链接是指在生成可执行文件时不将所有程序用到的函数链接到一个文件，因为有许多函数在操作系统带的dll文件中，当程序运行时直接从操作系统中找。 而静态链接就是把所有用到的函数全部链接到exe文件中。
	动态链接是只建立一个引用的接口，而真正的代码和数据存放在另外的可执行模块中，在运行时再装入；而静态链接是把所有的代码和数据都复制到本模块中，运行时就不再需要库了。

c程序辨别系统是16位or32位
	法一：int k=~0;
	
	if((unsigned int)k >63356) cout<<"at least 32bits"<<endl;
	else cout<<"16 bits"<<endl;
	
	法二：//32为系统
	
	int i=65536;
	cout<<i<<endl;
	int j=65535;
	cout<<j<<endl;
	
大端or小端字节序

	1) Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。
	2) Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。
	举一个例子，比如数字0x12 34 56 78在内存中的表示形式为：
	
	1)大端模式：
	低地址 -----------------> 高地址
	0x12  |  0x34  |  0x56  |  0x78
	2)小端模式：
	低地址 ------------------> 高地址
	0x78  |  0x56  |  0x34  |  0x12
	
	32bit宽的数0x12345678在Little-endian模式以及Big-endian模式）CPU内存中的存放方式（假设从地址0x4000开始存放）为：
	内存地址	小端模式存放内容    大端模式存放内容
	0x4000		0x78		0x12
	0x4001		0x56		0x34
	0x4002		0x34		0x56
	0x4003		0x12		0x78
	
	4)大端小端没有谁优谁劣，各自优势便是对方劣势：
	小端模式 ：强制转换数据不需要调整字节内容，1、2、4字节的存储方式一样。
	大端模式 ：符号位的判定固定为第一个字节，容易判断正负。


	BOOL IsBigEndian()  
	{  
	    int a = 0x1234;  
	    char b =  *(char *)&a;  //通过将int强制类型转换成char单字节，通过判断起始存储位置。即等于 取b等于a的低地址部分  
	    if( b == 0x12)  
	    {  
	        return TRUE;  
	    }  
	    return FALSE;  
	}

	联合体union的存放顺序是所有成员都从低地址开始存放，利用该特性可以轻松地获得了CPU对内存采用Little-endian还是Big-endian模式读写：

	BOOL IsBigEndian()  
	{  
	    union NUM  
	    {  
	        int a;  
	        char b;  
	    }num;  
	    num.a = 0x1234;  
	    if( num.b == 0x12 )  
	    {  
	        return TRUE;  
	    }  
	    return FALSE;  
	}

i++是否原子操作？并解释为什么
	
	i++分为三个阶段：
	内存到寄存器
	寄存器自增
	写回内存
	这三个阶段中间都可以被中断分离开.

linux系统的各类同步机制
	
	自旋锁,读写锁,原子操作,信号量,等待队列,

死锁必要条件及避免算法、

	1、互斥条件，资源不能共享，只能由一个进程使用。
	2、请求与保持条件（Hold andwait）：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
	3、不剥夺条件（Nopre-emption）：进程已获得的资源，在末使用完之前，不能强行剥夺。
	4、循环等待：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源

	处理死锁的策略：
	1.忽略该问题。例如鸵鸟算法，该算法可以应用在极少发生死锁的的情况下。为什么叫鸵鸟算法呢，因为传说中鸵鸟看到危险就把头埋在地底下，可能鸵鸟觉得看不到危险也就没危险了吧。跟掩耳盗铃有点像。
	2.检测死锁并且恢复。
	3.仔细地对资源进行动态分配，以避免死锁。
	4.通过破除死锁四个必要条件之一，来防止死锁产生。

exit()与_exit()的区别？

	_exit终止调用进程，但不关闭文件，不清除输出缓存，也不调用出口函数。
	exit函数将终止调用进程。在退出程序之前，所有文件关闭，缓冲输出内容将刷新定义，并调用所有已刷新的“出口函数”

linux的内存管理机制是什么？

		Linux虚拟内存的实现需要6种机制的支持：地址映射机制、内存分配回收机制、缓存和刷新机制、请求页机制、交换机制和内存共享机制
		内存管理程序通过映射机制把用户程序的逻辑地址映射到物理地址。当用户程序运行时，如果发现程序中要用的虚地址没有对应的物理内存，
	就发出了请求页要求。如果有空闲的内存可供分配，就请求分配内存(于是用到了内存的分配和回收)，并把正在使用的物理页记录在缓存中(使用了缓
	存机制)。如果没有足够的内存可供分配，那么就调用交换机制；腾出一部分内存。另外，在地址映射中要通过TLB(翻译后援存储器)来寻找物理页；
	交换机制中也要用到交换缓存，并且把物理页内容交换到交换文件中，也要修改页表来映射文件地址。

任务调度算法：

	1. 先来先服务
	2. 短作业优先算法
	3. 时间片轮转算法
	4. 优先级算法

五种I/O 模式—

	【1】阻塞I/O         (Linux下的I/O操作默认是阻塞I/O，即open和socket创建的I/O都是阻塞I/O)
	【2】非阻塞 I/O      (可以通过fcntl或者open时使用O_NONBLOCK参数，将fd设置为非阻塞的I/O)
	【3】I/O 多路复用    (I/O多路复用，通常需要非阻塞I/O配合使用)
	【4】信号驱动 I/O    (SIGIO)
	【5】异步 I/O

Apache 模型（Process Per Connection，简称PPC），TPC（ThreadPer Connection）模型，以及 select 模型和 poll 模型，epoll模型

	 PPC/TPC 模型
		这两种模型思想类似，就是让每一个到来的连接一边自己做事去，别再来烦我。只是 PPC 是为它开了一个进程，而 TPC 开了一个线程。
	可是别烦我是有代价的，它要时间和空间啊，连接多了之后，那么多的进程 / 线程切换，这开销就上来了；因此这类模型能接受的最大连接数都不
	会高，一般在几百个左右。

	select 模型
	1. 最大并发数限制，因为一个进程所打开的 FD （文件描述符）是有限制的，由FD_SETSIZE 设置，默认值是 1024/2048 ，因此 Select
	模型的最大并发数就被相应限制了。自己改改这个 FD_SETSIZE ？想法虽好，可是先看看下面吧 …
	2. 效率问题， select 每次调用都会线性扫描全部的 FD 集合，这样效率就会呈现线性下降，把 FD_SETSIZE 改大的后果就是，大家都慢慢来.
	3. 内核 / 用户空间内存拷贝问题，如何让内核把 FD 消息通知给用户空间呢？在这个问题上 select 采取了内存拷贝方法。

	poll 模型
	基本上效率和select 是相同的，select 缺点的 2 和 3 它都没有改掉。

	Epoll 的提升
	把其他模型逐个批判了一下，再来看看 Epoll 的改进之处吧，其实把 select 的缺点反过来那就是 Epoll 的优点了。
	3.1. Epoll 没有最大并发连接的限制，上限是最大可以打开文件的数目，这个数字一般远大于 2048, 一般来说这个数目和系统内存关系很大，
	具体数目可以 cat /proc/sys/fs/file-max 察看。
	3.2. 效率提升， Epoll 最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中， Epoll 的效率就会远远
	高于 select 和 poll 。
	3.3. 内存拷贝， Epoll 在这点上使用了“共享内存 ”，这个内存拷贝也省略了。

select和epoll的区别
	
		select的本质是采用32个整数的32位，即32*32= 1024来标识，fd值为1-1024。当fd的值超过1024限制时，就必须修改FD_SETSIZE
	的大小。这个时候就可以标识32*max值范围的fd。

	对于单进程多线程，每个线程处理多个fd的情况，select是不适合的。
	1.所有的线程均是从1-32*max进行扫描，每个线程处理的均是一段fd值，这样做有点浪费
	2.1024上限问题，一个处理多个用户的进程，fd值远远大于1024
	所以这个时候应该采用poll，
	
		poll传递的是数组头指针和该数组的长度，只要数组的长度不是很长，性能还是很不错的，因为poll一次在内核中申请4K（一个页的大小
	来存放fd），尽量控制在4K以内.
		epoll还是poll的一种优化，返回后不需要对所有的fd进行遍历，在内核中维持了fd的列表。select和poll是将这个内核列表维持在用
	户态，然后传递到内核中。但是只有在2.6的内核才支持。
		epoll更适合于处理大量的fd ，且活跃fd不是很多的情况，毕竟fd较多还是一个串行的操作
	
	epoll哪些触发模式，有啥区别？（必须非常详尽的解释水平触发和边缘触发的区别，以及边缘触发在编程中要做哪些更多的确认）
		epoll可以同时支持水平触发和边缘触发（Edge Triggered，只告诉进程哪些文件描述符刚刚变为就绪状态，它只说一遍，如果我们没有
	采取行动，那么它将不会再次告知，这种方式称为边缘触发），理论上边缘触发的性能要更高一些，但是代码实现相当复杂。
		epoll同样只告知那些就绪的文件描述符，而且当我们调用epoll_wait()获得就绪文件描述符时，返回的不是实际的描述符，而是一个代表
	就绪描述符数量的值，你只需要去epoll指定的一个数组中依次取得相应数量的文件描述符即可，这里也使用了内存映射（mmap）技术，这样便彻底省掉
	了这些文件描述符在系统调用时复制的开销。
		另一个本质的改进在于epoll采用基于事件的就绪通知方式。在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描
	述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速
	激活这个文件描述符，当进程调用epoll_wait()时便得到通知。	









